Types and operators
===================

JS is a dynamic typed language.

Primitive types
---------------
There are 6 primitive types:
* **undefined**: lack of existence from the JS engine.
* **null**: lack of existence from your code. You should set your variable to *null* if you wanna represent a lack of existance, not to *undefined*.
* **boolean**: true or false
* **number**: floating point number. It is the only numeric type.
* **string**: sequence of characters.
* **symbol**: used in ES6.

Precedence and Associativity
----------------------------
* *Operation precedence*: which operator function gets called first
* *Associativity*: what order the operator function get called in when functions have the same precedence, i.e.: right to left or viceversa

Here a table to refer to for precedence and associativity: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

Here an example with comments:

```javascript
var a =     // Assignement has a precedence of 3
        2 + // Addition has a precedence of 13
        3 * // Multiplication has a precedence of 18
        5;
```
The operation with higher precedence get called first...hence the multiplication in this case.

```javascript
var b =     // Assignement has a precedence of 3
        2 + // Addition has a precedence of 13
        3 - // Subtraction has a precedence of 13
        5;

```
Subtraction and addition have the same precedence. In order to decide which one to call first we need to check the associativity, which in this case is left to right, hence the addition gets called first.

Coercion
--------
Converting a value from a type to another.

```javascript
var a = 1 + '2';
console.log(a); // 12..1 has been coerced to a string.
```

Comparison operators
--------------------
The following example seems pretty obvious:

```javascript
console.log(1 < 2 < 3); // true
```
What about this other ?

```javascript
console.log(3 < 2 < 1); //true!!!
```
Let's try to explain it:
* We have 3 *"less than"* operators, hence they have the same precedence
* The associativity is left to right, this means that the first operation to be computed will be *3 < 2*, which returns *false*
* We now have the following:
```javascript
console.log(false < 1);
```
* JS will coerce *false* to a number which is *0*, hence the evaluation of *0 < 1* returns *true*

The first example result seemed obvious, but it is not so immediate to understand the reason why.

Particular cases of coersion
----------------------------

Some particular cases of coersion:

```javascript
Number(undefined); //NaN
Number(null); //0
3 == 3; // true
"3" == 3; // true..."3" string get coerced to 3 number
var a = false;
a == 0; //true
null == 0; //false!!!! Even if null coerce to 0!
null < 1; //true!!!! null doesn't coerce to 0 for comparison only!!
"" == 0; //true
"" == false; //true
```
> BEST PRACTICE: It is good practice to use strict equality (**===**) and inequality (**!==**) to avoid errors generated by a particular case of coercion. What this operator does is comparing two things WITHOUT trying to coerce them.

```javascript
3 === 3   //true
"3" === 3 //false
```
See the table under the "A model for understanding equality comparisons?" [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness) for more details.

If you wanna check for definedeness of a variable coercion plays an important role, see the example to explain why:

```javascript
// a will be coerced to true, so we will get into the if
var a = 1;
if (a) {
 console.log('Defined!');
}
// b will be coerced to false, so we won't get into the if even if we want to!
var b = 0;
if (b) {
 console.log('Defined!');
}
// in this case we are checking for defindness. c === 0 will coerce to true, and false || true will return true!
var c = 0;
if (c || c === 0) {
 console.log('Defined!');
}
```
Another useful case where coercion is leveraged is the value defaulting:

```javascript
var a = a || 1; // If a is undefined it will coerce to 0 and 0 || 1 => 1
```

